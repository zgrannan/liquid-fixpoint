Problem
-------

When dealing with functions over arithmetic operations, LiquidHaskell
provides a lot of automation due to the fact that the SMT solver is able to
automatically apply certain laws (such as associativity of `+`, transitivity
of `<` etc). Statements such as `a + (b + (c + d)) = ((a + b) + c) + d` are
proven automatically. However, when dealing with user-defined proofs,
LiquidHaskell will not automatically apply it, because the resulting SMT
output is typically not in a domain that SMT has the capability for native
support for. For example, list concatenation (denoted `++`) is associative,
i.e `(a ++ b) ++ c = a ++ (b ++ c)`. However to prove that `a ++ (b ++ (c ++
d)) = ((a ++ b) ++ c) ++ d` holds, it is necessary to manually apply the
proof of associativity


Ideally it should be possible to provide LiquidHaskell with a proof of some
equality, and then have it automatically apply that equality in subsequent
proofs.

Proposed Solution
-----------------

Although encoding such proofs in SMT directly as universally-quantified
equalities is possible, in practice this leads to divergence.

Instead, the solution is to allow equalities to be annotated with a `rewrite`
pragma if the user wishes them to be applied automatically. During PLE, when
Liquid Haskell encounters an expression, if the expression matches either
side of an equality with the a rewrite pragma, it will generate an SMT proof
of that specific instance of the rewrite equality, in addition to the
additional equalities generated by applying logical evaluation.

For example, the proof of the associative property would be defined as:

```haskell
{-@ rewrite assoc @-}
{-@ assoc :: as:[a] -> bs:[a] -> cs:[a]
          -> { (as ++ bs) ++ cs = as ++ (bs ++ cs) } @-}
assoc :: [a] -> [a] -> [a] -> ()
assoc [] _ _       = ()
assoc (_:as) bs cs = assoc as bs cs
```

With the rewrite rule, the following proof is automatic:

```haskell
{-@ assoc2 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a]
          -> { xs ++ (ys ++ (zs ++ ws)) = ((xs ++ ys) ++ zs) ++ ws } @-}
assoc2 :: [a] -> [a] -> [a] -> [a] -> ()
assoc2 xs ys zs ws = () left 
```

It does this because of the following steps:

When PLE evaluates the lhs of `assoc2` (i.e `xs ++ (ys ++ (zs ++ ws))`), it
matches against the rhs of `assoc` (i.e `as = xs, bs = ys, cs = (zs ++
ws)`), and generates the equality

```haskell
xs ++ (ys ++ (zs ++ ws)) = 
(xs ++ ys) ++ (zs ++ ws)
```
When PLE evaluates the rhs of `assoc2` (i.e `((xs ++ ys) ++ zs) ++ ws)`), it
matches against the lhs of `assoc` (i.e `as = (xs +ys), bs = zs, cs = ws`)
ws)`), and generates the equality

```haskell
`((xs ++ ys) ++ zs) ++ ws)` =
(xs ++ ys) ++ (zs ++ ws)
```

These two properties are sufficient to show prove assoc2. However, this
mechanism will also match the subterms of the lhs and rhs of assoc2 (such as
(xs ++ ys) ++ zs).

### A note about rewriting and free variables.

Depending on where free variables appear, rewriting can be done in either
two, one, or zero directions, where zero directions means that rewriting is
not possible. In the above direction, the `rewrite` for `assoc` can be done
in both directions (i.e matching against either `(as ++ bs) ++ cs or as ++
(bs ++ cs)`), because all variables bound in the lhs of the equality also
appear on the rhs of the equality.

However, consider the `const` function and corresponding proof:

```haskell
const _ y = y

{-@ rewrite constProof @-}
{-@ constProof :: x : a -> y : b -> { const x y = y } @-}
```

If we generate a term of from the lhs of the equality(i.e `const 1 2`), we
can generate the rhs of the equality (`2`) and generate the corresponding
SMT statement. However, we cannot generate a statement if we encounter only
the rhs, because there is no information that can be used to generate the
value `x`. In this case, we would only be able to apply the rewrite rule one
way. Furthermore, it's impossible to perform rewriting in the presence of a
proof like this:

```haskell

{-@ rewrite fgProof @-}
{-@ fgProof :: x : a -> y : b -> { f x = g y } @-}

```
Since we cannot generate the necessary information from either side of the
equality, it's not possible to generate such a rewrite.

