Problem
-------

When dealing with functions over arithmetic operations, LiquidHaskell
provides a lot of automation due to the fact that the SMT solver is able to
automatically apply certain laws (such as associativity of `+`, transitivity
of `<` etc). Statements such as `a + (b + (c + d)) = ((a + b) + c) + d` are
proven automatically. 

However, LiquidHaskell is not able to automatically user-defined proofs of
these properties over arbitrary-domains. For example, list concatenation
(denoted `++`) is associative, i.e `(a ++ b) ++ c = a ++ (b ++ c)`. However
to prove that `a ++ (b ++ (c ++ d)) = ((a ++ b) ++ c) ++ d` holds, it is
necessary to manually apply the proof of associativity manually, multiple
times.


Ideally it should be possible to provide LiquidHaskell with a proof of some
equality, and then have it automatically apply that equality in subsequent
proofs.

Proposed Solution
-----------------

Although encoding such proofs in SMT directly as universally-quantified
equalities is possible, in practice this leads to divergence.

Instead, the solution is to allow equalities to be annotated with a
`rewrite` pragma if the user wishes them to be applied automatically. During
PLE, when Liquid Haskell encounters an expression, if the expression matches
either side of an equality with the `rewrite` pragma, it will generate an
SMT proof of that specific instance of the rewrite equality in addition to
the equalities generated by applying PLE. Here, an expression `e` "matches"
a an expression `r` on either side of an equality proof if there is a way
to assign the free variables in `r` such that `r` = `e`. For example, the
proof of the associative property would be defined as:

```haskell
{-@ rewrite assoc @-}
{-@ assoc :: as:[a] -> bs:[a] -> cs:[a]
          -> { (as ++ bs) ++ cs = as ++ (bs ++ cs) } @-}
assoc :: [a] -> [a] -> [a] -> ()
assoc [] _ _       = ()
assoc (_:as) bs cs = assoc as bs cs
```

With the rewrite rule, the following proof is automatic:

```haskell
{-@ assoc2 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a]
          -> { xs ++ (ys ++ (zs ++ ws)) = ((xs ++ ys) ++ zs) ++ ws } @-}
assoc2 :: [a] -> [a] -> [a] -> [a] -> ()
assoc2 xs ys zs ws = () 
```

It does this because of the following steps:

When PLE evaluates the lhs of `assoc2` (i.e `xs ++ (ys ++ (zs ++ ws))`), it
matches against the rhs of `assoc` (i.e `as = xs, bs = ys, cs = (zs ++
ws)`), and generates the equality

```haskell
xs ++ (ys ++ (zs ++ ws)) = 
(xs ++ ys) ++ (zs ++ ws)
```
When PLE evaluates the rhs of `assoc2` (i.e `((xs ++ ys) ++ zs) ++ ws)`), it
matches against the lhs of `assoc` (i.e `as = (xs +ys), bs = zs, cs = ws`)
ws)`), and generates the equality

```haskell
`((xs ++ ys) ++ zs) ++ ws)` =
(xs ++ ys) ++ (zs ++ ws)
```

These two properties are sufficient to show prove assoc2. However, this
mechanism will also match the subterms of the lhs and rhs of assoc2 (such as
(xs ++ ys) ++ zs).

### A note about rewriting and free variables.

Depending on where free variables appear, rewriting can be done in either
two, one, or zero directions, where zero directions means that rewriting is
not possible. In the above direction, the `rewrite` for `assoc` can be done
in both directions (i.e matching against either `(as ++ bs) ++ cs or as ++
(bs ++ cs)`), because all variables bound in the lhs of the equality also
appear on the rhs of the equality.

However, consider the `const` function and corresponding proof:

```haskell
const _ y = y

{-@ rewrite constProof @-}
{-@ constProof :: x : a -> y : b -> { const x y = y } @-}
```

If we generate a term of from the lhs of the equality(i.e `const 1 2`), we
can generate the rhs of the equality (`2`) and generate the corresponding
SMT statement. However, we cannot generate a statement if we encounter only
the rhs, because there is no information that can be used to generate the
value `x`. Strictly speaking, this would translate into an universally
quantified proof (forall x), which would diverge. In this case, we would
only be able to apply the rewrite rule one way.

Furthermore, it's impossible to perform rewriting in the presence of a
proof like this:

```haskell

{-@ rewrite fgProof @-}
{-@ fgProof :: x : a -> y : b -> { f x = g y } @-}

```
Since we cannot generate the necessary information from either side of the
equality, it's not possible to generate such a rewrite.

### Recursive rewriting.

The above procedure for rewriting can automatically apply proofs one or two
times and eliminate a great deal of boilerplate code. However, this
mechanism is not sufficient to eliminate proof application entirely, because
it does not evaluate the expressions generated by rewriting.

For example, consider `assoc3`:

```haskell
{-@ assoc3 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a] -> us:[a]
          -> { xs ++ (ys ++ (us ++ (zs ++ ws))) = 
            (((xs ++ ys) ++ us) ++ zs) ++ ws} @-}
assoc3 :: [a] -> [a] -> [a] -> [a] -> [a] -> ()
assoc3 xs ys us zs ws = () 
```

To prove `assoc3`, it's necessary to prove the intermediate equality:

```
(xs ++ ys) ++ (us ++ (zs ++ ws)) =
((xs ++ ys) ++ us) ++ (zs ++ ws)
```

However, this equality cannot be generated by applying `assoc` to either
side of the equality in `assoc3`. 

It's worth noting, however, that we can still prove `assoc3` without
directly invoking `assoc` using equational reasoning.

```
assoc3 xs ys us zs ws =
      (xs ++ (ys ++ (us ++ (zs ++ ws)))
  === (xs ++ ys) ++ (us ++ (zs ++ ws))
  === ((xs ++ ys) ++ us) ++ (zs ++ ws)
  === (((xs ++ ys) ++ us) ++ zs) ++ ws
  *** QED
```

and this can be further simplified to

```
assoc3 xs ys us zs ws =
      (xs ++ ys) ++ (us ++ (zs ++ ws))
  === ((xs ++ ys) ++ us) ++ (zs ++ ws)
  *** QED
```

*However*, we could make a small change to the above algorithm to enable
rewriting to be applied recursively, thereby enabling equalities such as
`assoc3` to be applied automatically. Namely, when an equality `A = B` is
generated `A = B` via rewriting, we could run PLE on the new expression `B`,
thereby allowing the rewriting rule to be applied multiple times.

This approach introduces a potential problem though: which is that it may
not terminate.

Consider the equality

```haskell
{-@ rewrite concatIdentity @-}
{-@ concatIdentity :: xs : [a] -> {xs = xs ++ []} @-}
concatIdentity _ = ()
```

It's clear that this rewrite rule can be applied forever recursively,ie :

```haskell
xs = xs ++ []
xs ++ [] = xs ++ [] ++ []
xs ++ [] ++ [] = xs ++ [] ++ [] ++ []
...
```

and so on. One simple mechanism to prevent this from occurring would be to
set a limit of how many times rewriting could occur, for example, by
ensuring that any chain of rewrites starting from an expression must be less
than 10 expressions. Such a limit may also be desirable for performance reasons.
