Problem
-------

When dealing with functions over arithmetic operations, LiquidHaskell
provides a lot of automation because the SMT solver is able to automatically
apply certain laws (such as associativity of `+`, transitivity of `<`, etc).
Statements such as `a + (b + (c + d)) = ((a + b) + c) + d` are proven
automatically.

However, LiquidHaskell is not able to automatically apply user-defined
proofs of these properties over arbitrary domains. For example, list
concatenation (denoted `++`) is associative, i.e `(a ++ b) ++ c = a ++ (b ++
c)`. However, in order to prove
```
a ++ (b ++ (c ++ d)) = ((a ++ b) ++ c) ++ d
```
it is necessary to manually apply the proof of associativity multiple times.

Ideally it should be possible to provide LiquidHaskell with a proof of an
equality, and then instruct it to automatically apply the proof when
applicable.

Proposed Solution
-----------------

Although encoding such proofs in SMT directly as universally-quantified
assertions is possible, in practice this leads to divergence.

Instead, the proposed solution is to allow equalities to be annotated with a
`rewrite` pragma if the user wishes for them to be applied automatically.
During PLE, when Liquid Haskell encounters an expression, if the expression
matches either side of an equality with the `rewrite` pragma, it will
generate an SMT proof of that specific instance of the rewrite equality, in
addition to the equalities generated by applying PLE. 

More formally, an expression `e` can be rewritten to an expression `e'` if
there is a rewrite expression `r = r'` or `r' = r`, and a substitution `s`
of the free variables in `r` such that `e = r`. Namely, the expression `e'`
is the substitution of `s` in `r'`.

For example, consider the following proof of associativity of `++` on lists:

```haskell
{-@ rewrite assoc @-}
{-@ assoc :: as:[a] -> bs:[a] -> cs:[a]
          -> { (as ++ bs) ++ cs = as ++ (bs ++ cs) } @-}
assoc :: [a] -> [a] -> [a] -> ()
assoc [] _ _       = ()
assoc (_:as) bs cs = assoc as bs cs
```

Using the above rewrite rule, we can automatically prove  a more complex
theorem:

```haskell
{-@ assoc2 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a]
          -> { xs ++ (ys ++ (zs ++ ws)) = ((xs ++ ys) ++ zs) ++ ws } @-}
assoc2 :: [a] -> [a] -> [a] -> [a] -> ()
assoc2 xs ys zs ws = () 
```

Here's how it works:

First, PLE evaluates the left-hand side of `assoc2`:
```
xs ++ (ys ++ (zs ++ ws))
```

This expression matches the right-hand side of assoc using the following
substitution: 

```
as = xs
bs = ys
cs = zs ++ ws
```

Therefore, the following equality is automatically generated:

```
xs ++ (ys ++ (zs ++ ws)) = 
(xs ++ ys) ++ (zs ++ ws)
```

Next, PLE evaluates the right-hand side of `assoc2`:

```
(xs ++ ys) ++ zs) ++ ws
```

This expression matches the right-hand side of assoc using the following
substitution: 

```
as = (xs +ys)
bs = zs
cs = ws
```

Therefore, the following equality is generated:

```
((xs ++ ys) ++ zs) ++ ws) =
(xs ++ ys) ++ (zs ++ ws)
```

These two properties are sufficient to show prove assoc2, because SMT will
automatically apply the transitivity of equality.

### A note about rewriting and free variables.

Depending on where free variables appear, rewriting can be performed in
either one or two directions.

In the above example, a rewrite can be generated for any expression that
matches the left-hand side or right-hand side of `assoc`, because all free
variables appear on both sides of the equality.

However, consider the `const` function and corresponding proof:

```haskell
const _ y = y

{-@ rewrite constProof @-}
{-@ constProof :: x : a -> y : b -> { const x y = y } @-}
```

If we encounter a term that matches the left-hand side of the equality (for
example, `const 1 2`), we can generate the rewrite equality (`const 1 2 =
2`). However, if we encounter an expression that matches the right-hand side
of the equality, it's not possible to generate the left-hand side because we
don't have a fixed value for `x`. Technically speaking, this would require
the generation of an universally-quantified SMT assertion, which could cause
divergence.

Furthermore, if the left-hand side of an equality includes variables that
are not bound on the right-hand side, and the right-hand side of an equality
includes variables that are not bound on the left-hand side, then automatic
rewriting is not possible. For example, consider this function:

```haskell

{-@ rewrite fgProof @-}
{-@ fgProof :: x : a -> y : b -> { f x = g y } @-}

```

If we were to attempt a match on the left-hand side, we don't know what
value to use for `y` and if we attempted a match on the right-hand side, we
wouldn't have a value for `x`.

### Recursive rewriting.

The above procedure for rewriting can eliminate a great deal of boilerplate,
but does not fully automate proof application for rewrite equalities. This
is because the algorithm as written above does not evaluate expressions
generated by rewriting.

For example, consider `assoc3`:

```haskell
{-@ assoc3 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a] -> us:[a]
          -> { xs ++ (ys ++ (us ++ (zs ++ ws))) = 
            (((xs ++ ys) ++ us) ++ zs) ++ ws} @-}
assoc3 :: [a] -> [a] -> [a] -> [a] -> [a] -> ()
assoc3 xs ys us zs ws = () 
```

To prove `assoc3`, it's necessary to prove the intermediate equality:

```
(xs ++ ys) ++ (us ++ (zs ++ ws)) =
((xs ++ ys) ++ us) ++ (zs ++ ws)
```

However, this equality cannot be generated by applying `assoc` to either
side of the equality in `assoc3`. 

It's worth noting, however, that we can still prove `assoc3` without
directly invoking `assoc` by using equational reasoning.

```haskell
assoc3 xs ys us zs ws =
      (xs ++ (ys ++ (us ++ (zs ++ ws)))
  === (xs ++ ys) ++ (us ++ (zs ++ ws))
  === ((xs ++ ys) ++ us) ++ (zs ++ ws)
  === (((xs ++ ys) ++ us) ++ zs) ++ ws
  *** QED
```

and this can be further simplified to

```haskell
assoc3 xs ys us zs ws =
      (xs ++ ys) ++ (us ++ (zs ++ ws))
  === ((xs ++ ys) ++ us) ++ (zs ++ ws)
  *** QED
```

*However*, we could make a small change to the above algorithm to enable
rewriting to be applied recursively, and therefore enable equalities such as
`assoc3` to be proven automatically. Namely, when an equality `A = B` is
generated via rewriting, we could run PLE on the new expression `B`, as
well. This could generate a new rewrite `B = C`, and evaluating C could lead
to a new rewrite `C = D`, etc.

However, this approach may not terminate. Consider the equality:

```haskell
{-@ rewrite concatIdentity @-}
{-@ concatIdentity :: xs : [a] -> {xs = xs ++ []} @-}
concatIdentity _ = ()
```

It's clear that this rewrite rule can be applied forever recursively,i.e :

```haskell
xs = xs ++ []
xs ++ [] = xs ++ [] ++ []
xs ++ [] ++ [] = xs ++ [] ++ [] ++ []
...
```

and so on. One simple mechanism to prevent this from occurring would be to
set a limit of how many times rewriting could occur, for example, by
ensuring that any chain of rewrites starting from an expression must be less
than 10 expressions. Such a limit may be desirable for performance reasons
anyways.

Questions
---------

How can we generate the substitution for the rewrite? For example, if
we encounter a term like

```
xs ++ ([1,2,3] ++ f y)
```

how do we match with the right-hand side of `assoc` and get the substitution

```
as = xs
bs = [1,2,3]
cs = f y
```


